// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_API_API_H_
#define FLATBUFFERS_GENERATED_API_API_H_

#include "flatbuffers/flatbuffers.h"

namespace API {

    struct Vec2;

    struct PlayerMove;

    struct PlayerOnMove;

    struct Msg;

    enum Direction {
        Direction_left = 0,
        Direction_right = 1,
        Direction_up = 2,
        Direction_down = 3,
        Direction_MIN = Direction_left,
        Direction_MAX = Direction_down
    };

    inline const char **EnumNamesDirection() {
        static const char *names[] = {
                "left",
                "right",
                "up",
                "down",
                nullptr
        };
        return names;
    }

    inline const char *EnumNameDirection(Direction e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesDirection()[index];
    }

    enum MsgType {
        MsgType_NONE = 0,
        MsgType_PlayerMove = 1,
        MsgType_PlayerOnMove = 2,
        MsgType_MIN = MsgType_NONE,
        MsgType_MAX = MsgType_PlayerOnMove
    };

    inline const char **EnumNamesMsgType() {
        static const char *names[] = {
                "NONE",
                "PlayerMove",
                "PlayerOnMove",
                nullptr
        };
        return names;
    }

    inline const char *EnumNameMsgType(MsgType e) {
        const size_t index = static_cast<int>(e);
        return EnumNamesMsgType()[index];
    }

    template<typename T>
    struct MsgTypeTraits {
        static const MsgType enum_value = MsgType_NONE;
    };

    template<>
    struct MsgTypeTraits<PlayerMove> {
        static const MsgType enum_value = MsgType_PlayerMove;
    };

    template<>
    struct MsgTypeTraits<PlayerOnMove> {
        static const MsgType enum_value = MsgType_PlayerOnMove;
    };

    bool VerifyMsgType(flatbuffers::Verifier &verifier, const void *obj, MsgType type);
    bool
    VerifyMsgTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                        const flatbuffers::Vector<uint8_t> *types);

    MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
    private:
        int32_t x_;
        int32_t y_;

    public:
        Vec2() {
            memset(this, 0, sizeof(Vec2));
        }

        Vec2(const Vec2 &_o) {
            memcpy(this, &_o, sizeof(Vec2));
        }

        Vec2(int32_t _x, int32_t _y)
                : x_(flatbuffers::EndianScalar(_x)),
                  y_(flatbuffers::EndianScalar(_y)) {
        }

        int32_t x() const {
            return flatbuffers::EndianScalar(x_);
        }

        int32_t y() const {
            return flatbuffers::EndianScalar(y_);
        }
    };

    STRUCT_END(Vec2, 8);

    struct PlayerMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_ID = 4,
            VT_DIRECTION = 6,
            VT_POS = 8
        };

        const flatbuffers::String *id() const {
            return GetPointer<const flatbuffers::String *>(VT_ID);
        }

        Direction direction() const {
            return static_cast<Direction>(GetField<int8_t>(VT_DIRECTION, 0));
        }

        const Vec2 *pos() const {
            return GetStruct<const Vec2 *>(VT_POS);
        }

        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyOffset(verifier, VT_ID) &&
                   verifier.Verify(id()) &&
                   VerifyField<int8_t>(verifier, VT_DIRECTION) &&
                   VerifyField<Vec2>(verifier, VT_POS) &&
                   verifier.EndTable();
        }
    };

    struct PlayerMoveBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;

        void add_id(flatbuffers::Offset<flatbuffers::String> id) {
            fbb_.AddOffset(PlayerMove::VT_ID, id);
        }

        void add_direction(Direction direction) {
            fbb_.AddElement<int8_t>(PlayerMove::VT_DIRECTION, static_cast<int8_t>(direction), 0);
        }

        void add_pos(const Vec2 *pos) {
            fbb_.AddStruct(PlayerMove::VT_POS, pos);
        }

        PlayerMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }

        PlayerMoveBuilder &operator=(const PlayerMoveBuilder &);

        flatbuffers::Offset<PlayerMove> Finish() {
            const auto end = fbb_.EndTable(start_, 3);
            auto o = flatbuffers::Offset<PlayerMove>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<PlayerMove> CreatePlayerMove(
            flatbuffers::FlatBufferBuilder &_fbb,
            flatbuffers::Offset<flatbuffers::String> id = 0,
            Direction direction = Direction_left,
            const Vec2 *pos = 0) {
        PlayerMoveBuilder builder_(_fbb);
        builder_.add_pos(pos);
        builder_.add_id(id);
        builder_.add_direction(direction);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<PlayerMove> CreatePlayerMoveDirect(
            flatbuffers::FlatBufferBuilder &_fbb,
            const char *id = nullptr,
            Direction direction = Direction_left,
            const Vec2 *pos = 0) {
        return API::CreatePlayerMove(
                _fbb,
                id ? _fbb.CreateString(id) : 0,
                direction,
                pos);
    }

    struct PlayerOnMove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_ID = 4,
            VT_DIRECTION = 6
        };

        const flatbuffers::String *id() const {
            return GetPointer<const flatbuffers::String *>(VT_ID);
        }

        Direction direction() const {
            return static_cast<Direction>(GetField<int8_t>(VT_DIRECTION, 0));
        }

        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyOffset(verifier, VT_ID) &&
                   verifier.Verify(id()) &&
                   VerifyField<int8_t>(verifier, VT_DIRECTION) &&
                   verifier.EndTable();
        }
    };

    struct PlayerOnMoveBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;

        void add_id(flatbuffers::Offset<flatbuffers::String> id) {
            fbb_.AddOffset(PlayerOnMove::VT_ID, id);
        }

        void add_direction(Direction direction) {
            fbb_.AddElement<int8_t>(PlayerOnMove::VT_DIRECTION, static_cast<int8_t>(direction), 0);
        }

        PlayerOnMoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }

        PlayerOnMoveBuilder &operator=(const PlayerOnMoveBuilder &);

        flatbuffers::Offset<PlayerOnMove> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<PlayerOnMove>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<PlayerOnMove> CreatePlayerOnMove(
            flatbuffers::FlatBufferBuilder &_fbb,
            flatbuffers::Offset<flatbuffers::String> id = 0,
            Direction direction = Direction_left) {
        PlayerOnMoveBuilder builder_(_fbb);
        builder_.add_id(id);
        builder_.add_direction(direction);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<PlayerOnMove> CreatePlayerOnMoveDirect(
            flatbuffers::FlatBufferBuilder &_fbb,
            const char *id = nullptr,
            Direction direction = Direction_left) {
        return API::CreatePlayerOnMove(
                _fbb,
                id ? _fbb.CreateString(id) : 0,
                direction);
    }

    struct Msg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_DATA_TYPE = 4,
            VT_DATA = 6
        };

        MsgType data_type() const {
            return static_cast<MsgType>(GetField<uint8_t>(VT_DATA_TYPE, 0));
        }

        const void *data() const {
            return GetPointer<const void *>(VT_DATA);
        }

        template<typename T>
        const T *data_as() const;

        const PlayerMove *data_as_PlayerMove() const {
            return data_type() == MsgType_PlayerMove ? static_cast<const PlayerMove *>(data()) : nullptr;
        }

        const PlayerOnMove *data_as_PlayerOnMove() const {
            return data_type() == MsgType_PlayerOnMove ? static_cast<const PlayerOnMove *>(data()) : nullptr;
        }

        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
                   VerifyOffset(verifier, VT_DATA) &&
                   VerifyMsgType(verifier, data(), data_type()) &&
                   verifier.EndTable();
        }
    };

    template<>
    inline const PlayerMove *Msg::data_as<PlayerMove>() const {
        return data_as_PlayerMove();
    }

    template<>
    inline const PlayerOnMove *Msg::data_as<PlayerOnMove>() const {
        return data_as_PlayerOnMove();
    }

    struct MsgBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;

        void add_data_type(MsgType data_type) {
            fbb_.AddElement<uint8_t>(Msg::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
        }

        void add_data(flatbuffers::Offset<void> data) {
            fbb_.AddOffset(Msg::VT_DATA, data);
        }

        MsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }

        MsgBuilder &operator=(const MsgBuilder &);

        flatbuffers::Offset<Msg> Finish() {
            const auto end = fbb_.EndTable(start_, 2);
            auto o = flatbuffers::Offset<Msg>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Msg> CreateMsg(
            flatbuffers::FlatBufferBuilder &_fbb,
            MsgType data_type = MsgType_NONE,
            flatbuffers::Offset<void> data = 0) {
        MsgBuilder builder_(_fbb);
        builder_.add_data(data);
        builder_.add_data_type(data_type);
        return builder_.Finish();
    }

    inline bool VerifyMsgType(flatbuffers::Verifier &verifier, const void *obj, MsgType type) {
        switch (type) {
            case MsgType_NONE: {
                return true;
            }
            case MsgType_PlayerMove: {
                auto ptr = reinterpret_cast<const PlayerMove *>(obj);
                return verifier.VerifyTable(ptr);
            }
            case MsgType_PlayerOnMove: {
                auto ptr = reinterpret_cast<const PlayerOnMove *>(obj);
                return verifier.VerifyTable(ptr);
            }
            default:
                return false;
        }
    }

    inline bool
    VerifyMsgTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
                        const flatbuffers::Vector<uint8_t> *types) {
        if (values->size() != types->size()) return false;
        for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
            if (!VerifyMsgType(
                    verifier, values->Get(i), types->GetEnum<MsgType>(i))) {
                return false;
            }
        }
        return true;
    }

    inline const API::Msg *GetMsg(const void *buf) {
        return flatbuffers::GetRoot<API::Msg>(buf);
    }

    inline bool VerifyMsgBuffer(
            flatbuffers::Verifier &verifier) {
        return verifier.VerifyBuffer<API::Msg>(nullptr);
    }

    inline void FinishMsgBuffer(
            flatbuffers::FlatBufferBuilder &fbb,
            flatbuffers::Offset<API::Msg> root) {
        fbb.Finish(root);
    }

}  // namespace API

#endif  // FLATBUFFERS_GENERATED_API_API_H_
